<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>📕D2024_6_20 | Hrein's Blog</title><meta name="author" content="Hrein"><meta name="copyright" content="Hrein"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Kafka和RocketMQKafkaApache Kafka 是一个分布式流处理平台，主要用于构建实时数据管道和流应用。它是水平可扩展的，容错性强，且能够以毫秒级延迟处理数据。 以下是Kafka的主要组件：  Producer：生产者是发送消息到Kafka topics的客户端应用程序。  Consumer：消费者是从Kafka topics读取消息的客户端应用程序。  Broker：Kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="📕D2024_6_20">
<meta property="og:url" content="https://qhiqiefnqe-f.github.io/2024/06/20/Diary/2024_6_20/index.html">
<meta property="og:site_name" content="Hrein&#39;s Blog">
<meta property="og:description" content="Kafka和RocketMQKafkaApache Kafka 是一个分布式流处理平台，主要用于构建实时数据管道和流应用。它是水平可扩展的，容错性强，且能够以毫秒级延迟处理数据。 以下是Kafka的主要组件：  Producer：生产者是发送消息到Kafka topics的客户端应用程序。  Consumer：消费者是从Kafka topics读取消息的客户端应用程序。  Broker：Kafka">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/Screenshot_2024-08-13-16-39-50-25_2332cb9b27b851b.jpg">
<meta property="article:published_time" content="2024-06-20T01:40:09.000Z">
<meta property="article:modified_time" content="2024-09-15T14:04:15.176Z">
<meta property="article:author" content="Hrein">
<meta property="article:tag" content="backend">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/Screenshot_2024-08-13-16-39-50-25_2332cb9b27b851b.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qhiqiefnqe-f.github.io/2024/06/20/Diary/2024_6_20/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '📕D2024_6_20',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-15 22:04:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/Screenshot_2024-08-13-16-39-50-25_2332cb9b27b851b.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/IMG_20240915_160126(1).jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hrein's Blog"><span class="site-name">Hrein's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">📕D2024_6_20</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-20T01:40:09.000Z" title="发表于 2024-06-20 09:40:09">2024-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-15T14:04:15.176Z" title="更新于 2024-09-15 22:04:15">2024-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Diary/">Diary</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="📕D2024_6_20"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Kafka和RocketMQ"><a href="#Kafka和RocketMQ" class="headerlink" title="Kafka和RocketMQ"></a>Kafka和RocketMQ</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p><strong>Apache Kafka</strong> 是一个分布式流处理平台，主要用于构建实时数据管道和流应用。它是水平可扩展的，容错性强，且能够以毫秒级延迟处理数据。</p>
<p>以下是Kafka的主要组件：</p>
<ol>
<li><p><strong>Producer</strong>：生产者是发送消息到Kafka topics的客户端应用程序。</p>
</li>
<li><p><strong>Consumer</strong>：消费者是从Kafka topics读取消息的客户端应用程序。</p>
</li>
<li><p><strong>Broker</strong>：Kafka集群包含一个或多个服务器，这些服务器被称为broker。</p>
</li>
<li><p><strong>Topic</strong>：消息被分类的特定类别被称为topic。生产者将消息发送到特定的topic，消费者从特定的topic读取消息。</p>
</li>
<li><p><strong>Partition</strong>：Kafka topics被分割成多个分区，每个分区可以在不同的服务器上。</p>
</li>
<li><p><strong>Offset</strong>：每个分区中的每条消息都有一个唯一的序列号，称为offset。</p>
</li>
<li><p><strong>Zookeeper</strong>：Kafka使用Zookeeper来存储集群元数据，如存在哪些broker、消费者组的信息等。</p>
</li>
</ol>
<p>Kafka的工作流程如下：</p>
<ul>
<li>生产者将消息发送到特定的topic。</li>
<li>Kafka broker接收到消息后，将其附加到该topic的分区中。</li>
<li>消费者从这些分区中读取消息。消费者在每个分区中的位置由offset表示，这个offset由消费者自己维护。</li>
</ul>
<p>Kafka的主要特点包括：</p>
<ul>
<li><strong>高吞吐量</strong>：Kafka可以处理每秒数百万条消息，适合大数据处理。</li>
<li><strong>持久性</strong>：Kafka将消息存储在磁盘上，因此即使系统崩溃，消息也不会丢失。</li>
<li><strong>实时性</strong>：Kafka可以在毫秒级别处理数据，适合实时数据处理。</li>
<li><strong>分布式设计</strong>：Kafka集群可以横向扩展，通过增加更多的节点来提高处理能力。</li>
</ul>
<p>总的来说，Kafka是一个强大的流处理平台，适合构建高吞吐量、低延迟的实时数据处理系统。</p>
<hr>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p><strong>RocketMQ</strong> 是阿里巴巴开源的一款分布式消息中间件，主要用于处理大规模消息，提供低延迟、高可靠性、可扩展性强的消息传递能力。</p>
<p>以下是RocketMQ的主要组件：</p>
<ol>
<li><p><strong>Producer</strong>：生产者是发送消息到RocketMQ的客户端应用程序。</p>
</li>
<li><p><strong>Consumer</strong>：消费者是从RocketMQ读取消息的客户端应用程序。</p>
</li>
<li><p><strong>Broker</strong>：Broker是RocketMQ的服务端，用于存储消息、处理生产者请求和消费者请求。</p>
</li>
<li><p><strong>NameServer</strong>：NameServer是RocketMQ的注册中心，用于管理Broker。</p>
</li>
<li><p><strong>Topic</strong>：消息被分类的特定类别被称为topic。生产者将消息发送到特定的topic，消费者从特定的topic读取消息。</p>
</li>
<li><p><strong>Message Queue</strong>：RocketMQ的Topic被分割成多个Message Queue，每个Message Queue可以在不同的Broker上。</p>
</li>
</ol>
<p>RocketMQ的工作流程如下：</p>
<ul>
<li>生产者将消息发送到特定的topic。</li>
<li>Broker接收到消息后，将其存储在对应的Message Queue中。</li>
<li>消费者从这些Message Queue中读取消息。</li>
</ul>
<p>RocketMQ的主要特点包括：</p>
<ul>
<li><strong>高可靠性</strong>：RocketMQ有多种机制来保证消息的可靠性，例如消息复制、消息持久化等。</li>
<li><strong>低延迟</strong>：RocketMQ设计上采用了很多优化措施来保证低延迟，例如批量发送、异步刷新等。</li>
<li><strong>丰富的消息模型</strong>：RocketMQ支持发布&#x2F;订阅模型和点对点模型，还支持顺序消息、延迟消息等。</li>
<li><strong>强大的大规模消息处理能力</strong>：RocketMQ可以处理每秒上百万级别的消息。</li>
</ul>
<p>总的来说，RocketMQ是一个强大的消息中间件，适合构建高可靠性、低延迟的大规模消息处理系统。</p>
<hr>
<h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p><strong>Apache Kafka</strong> 和 <strong>RocketMQ</strong> 都是优秀的消息中间件，但它们在设计理念、特性和使用场景上有一些不同。</p>
<p>以下是它们的主要区别：</p>
<ol>
<li><p><strong>设计理念</strong>：</p>
<ul>
<li>Kafka更像是一个分布式的、可持久化的、可复制的、分区的提交日志服务，它以时间复杂度为O(1)的方式提供消息持久化能力，非常适合大数据处理。</li>
<li>RocketMQ更像是一个传统的消息中间件，它提供了丰富的消息模型（如顺序消息、事务消息等），并且在保证消息可靠性方面做了很多工作。</li>
</ul>
</li>
<li><p><strong>消息模型</strong>：</p>
<ul>
<li>Kafka只支持发布&#x2F;订阅模型。</li>
<li>RocketMQ支持发布&#x2F;订阅模型和点对点模型，还支持顺序消息、延迟消息等。</li>
</ul>
</li>
<li><p><strong>消息顺序保证</strong>：</p>
<ul>
<li>Kafka只能保证同一个分区内的消息顺序。</li>
<li>RocketMQ可以保证全局的严格消息顺序。</li>
</ul>
</li>
<li><p><strong>消息延迟</strong>：</p>
<ul>
<li>Kafka的消息延迟相对较高，因为它是以批量的方式来处理消息的。</li>
<li>RocketMQ的消息延迟相对较低，因为它支持即时消息拉取。</li>
</ul>
</li>
<li><p><strong>可用性</strong>：</p>
<ul>
<li>Kafka的高可用性依赖于Zookeeper，如果Zookeeper出现问题，Kafka也会受到影响。</li>
<li>RocketMQ的高可用性不依赖于外部系统，它自身就可以处理Broker的故障转移。</li>
</ul>
</li>
<li><p><strong>易用性</strong>：</p>
<ul>
<li>Kafka的API相对简单，但是它的配置参数非常多，调优比较复杂。</li>
<li>RocketMQ的API和配置参数都比较简单，易用性较好。</li>
</ul>
</li>
</ol>
<p>总的来说，Kafka和RocketMQ各有优势，选择哪一个取决于你的具体需求。如果你需要处理大数据，Kafka可能是一个更好的选择。如果你需要丰富的消息模型和高可靠性，RocketMQ可能更适合你。</p>
<h1 id="什么是端口？"><a href="#什么是端口？" class="headerlink" title="什么是端口？"></a>什么是端口？</h1><p><em>实际就是用于标识进程</em></p>
<p>在计算机网络中，端口（Port）是网络设备用于识别和管理传输数据的逻辑接口。它们是通过操作系统分配的标识符，用于区分不同的网络服务和应用程序。每个端口都有一个唯一的编号，称为端口号（Port Number）。</p>
<h3 id="端口的工作原理"><a href="#端口的工作原理" class="headerlink" title="端口的工作原理"></a>端口的工作原理</h3><p>当数据在网络上传输时，源设备和目标设备需要有一种方法来识别数据应该发送到或接收到哪个应用程序。端口号就提供了这种方法。例如，网络设备可以通过IP地址找到目标设备，但需要通过端口号找到目标设备上的特定应用程序。</p>
<h3 id="端口号的分类"><a href="#端口号的分类" class="headerlink" title="端口号的分类"></a>端口号的分类</h3><p>端口号是一个16位的整数，因此其值范围是0到65535。它们通常分为三个范围：</p>
<ol>
<li><p><strong>公认端口（Well-Known Ports）</strong>：范围是0到1023。这些端口号通常保留给常见的服务和协议，例如HTTP（端口80）、HTTPS（端口443）、FTP（端口21）和SMTP（端口25）。</p>
</li>
<li><p><strong>注册端口（Registered Ports）</strong>：范围是1024到49151。这些端口号用于特定的服务和应用程序，但不像公认端口那样标准化。</p>
</li>
<li><p><strong>动态&#x2F;私有端口（Dynamic&#x2F;Private Ports）</strong>：范围是49152到65535。这些端口号通常用于临时的或私有的连接。例如，当你在浏览器中打开一个网页时，浏览器会使用一个动态端口号来与服务器通信。</p>
</li>
</ol>
<h3 id="端口的使用"><a href="#端口的使用" class="headerlink" title="端口的使用"></a>端口的使用</h3><p>在TCP&#x2F;IP协议中，端口分为TCP端口和UDP端口：</p>
<ul>
<li><strong>TCP端口</strong>：用于面向连接的传输，确保数据包按顺序和无错误地传输。例如，HTTP（80）、HTTPS（443）等服务使用TCP端口。</li>
<li><strong>UDP端口</strong>：用于无连接的传输，不保证数据包的顺序和可靠性，但传输速度快，适用于实时应用。例如，DNS（53）、视频流和在线游戏等使用UDP端口。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你在浏览器中访问一个网页：</p>
<ol>
<li>浏览器会向操作系统请求一个动态端口（例如49160）。</li>
<li>浏览器通过该端口发送HTTP请求到目标服务器的80端口。</li>
<li>服务器在80端口接收到请求后，处理请求并返回数据。</li>
<li>浏览器通过原来的动态端口接收数据并显示网页。</li>
</ol>
<p>通过端口，计算机可以同时处理多个网络连接和应用程序，而不会混淆数据流。</p>
<p>希望这些信息对你有帮助！如果你还有其他问题，随时告诉我。</p>
<h1 id="什么是API"><a href="#什么是API" class="headerlink" title="什么是API"></a>什么是API</h1><p>当然可以！</p>
<h3 id="什么是API-1"><a href="#什么是API-1" class="headerlink" title="什么是API"></a>什么是API</h3><p>API（Application Programming Interface，应用程序编程接口）是一组定义和协议，用于构建和集成应用软件。它允许不同的软件系统之间进行通信和数据交换。API提供了一种标准化的方式，使开发者能够利用其他软件的功能，而无需了解其内部实现细节。</p>
<h3 id="API的工作原理"><a href="#API的工作原理" class="headerlink" title="API的工作原理"></a>API的工作原理</h3><p>API充当了不同软件系统之间的桥梁。当一个应用程序需要使用另一个应用程序的功能或数据时，它会通过API发送请求。API接收请求后，执行相应的操作，并返回结果。这种交互通常是通过HTTP协议进行的，特别是在Web API中。</p>
<h3 id="API的组成部分"><a href="#API的组成部分" class="headerlink" title="API的组成部分"></a>API的组成部分</h3><ol>
<li><p><strong>端点（Endpoints）</strong>：API提供的特定功能或服务的访问点，通常是一个URL。例如，<code>https://api.example.com/users</code>可能是一个获取用户信息的端点。</p>
</li>
<li><p><strong>请求方法（Request Methods）</strong>：HTTP方法，如GET、POST、PUT、DELETE等，定义了客户端如何与API交互。例如，GET请求用于获取数据，POST请求用于提交数据。</p>
</li>
<li><p><strong>请求头（Request Headers）</strong>：包含元数据的部分，如认证信息、数据格式等。</p>
</li>
<li><p><strong>请求体（Request Body）</strong>：在POST和PUT请求中，包含需要发送到服务器的数据。</p>
</li>
<li><p><strong>响应状态码（Response Status Codes）</strong>：服务器返回的状态码，用于指示请求的结果。例如，200表示成功，404表示资源未找到，500表示服务器错误。</p>
</li>
<li><p><strong>响应体（Response Body）</strong>：服务器返回的数据，通常是JSON或XML格式。</p>
</li>
</ol>
<h3 id="API的类型"><a href="#API的类型" class="headerlink" title="API的类型"></a>API的类型</h3><ol>
<li><p><strong>Web API</strong>：最常见的一种API，通过HTTP&#x2F;HTTPS协议进行通信，通常用于Web服务和应用的交互。</p>
</li>
<li><p><strong>库和框架API</strong>：软件库和框架提供的API，用于本地调用其功能。例如，Python标准库提供的API。</p>
</li>
<li><p><strong>操作系统API</strong>：操作系统提供的API，允许应用程序与操作系统进行交互。例如，文件系统操作API。</p>
</li>
</ol>
<h3 id="API的优点"><a href="#API的优点" class="headerlink" title="API的优点"></a>API的优点</h3><ol>
<li><p><strong>抽象和简化</strong>：API隐藏了复杂的实现细节，使开发者能够专注于业务逻辑。</p>
</li>
<li><p><strong>复用和集成</strong>：通过API，可以轻松地复用已有的功能和服务，提高开发效率。</p>
</li>
<li><p><strong>标准化和一致性</strong>：API提供标准化的接口，保证了不同系统之间的一致性和互操作性。</p>
</li>
<li><p><strong>扩展性</strong>：API使得系统可以更容易地扩展和升级，而不会影响现有功能。</p>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设你正在开发一个天气应用，需要获取当前的天气信息：</p>
<ol>
<li><p>你可以使用一个天气服务提供的API，例如<code>https://api.weather.com/v3/wx/conditions/current?apiKey=YOUR_API_KEY&amp;language=en-US&amp;format=json</code>。</p>
</li>
<li><p>你发送一个GET请求到这个API端点，并提供必要的参数，如API密钥和返回格式。</p>
</li>
<li><p>API返回包含天气信息的JSON数据。</p>
</li>
<li><p>你的应用程序解析这个JSON数据并显示当前天气信息。</p>
</li>
</ol>
<p>通过API，你能够快速集成和使用外部服务提供的功能，而无需自己实现复杂的天气数据处理逻辑。</p>
<p>如果你还有其他问题或需要更详细的解释，请随时告诉我！</p>
<h1 id="什么是socket"><a href="#什么是socket" class="headerlink" title="什么是socket"></a>什么是socket</h1><p>![[Pasted image 20240620171712.png]]<br><em>网络传输功能实际上是各种类型的sock结合硬件共同实现的，而为了将这部分功能暴露给用户空间的应用程序使用，于是引入了socket层，用户就可以在用户空间使用句柄，也就是socket FD来操作内核sock的网络传输能力</em><br><strong>翻译为套接字可以理解为一套用于连接的数字</strong></p>
<h3 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket"></a>什么是Socket</h3><p>Socket（套接字）是计算机网络通信中的一个抽象概念，用于描述两台设备之间的通信端点。它是网络编程的基础，提供了在网络上传输数据的接口。Socket能够在不同网络协议（如TCP&#x2F;IP、UDP等）下实现通信。</p>
<h3 id="Socket的工作原理"><a href="#Socket的工作原理" class="headerlink" title="Socket的工作原理"></a>Socket的工作原理</h3><p>Socket实际上是操作系统为应用程序提供的一种机制，使应用程序能够通过网络发送和接收数据。以下是Socket通信的基本过程：</p>
<ol>
<li><strong>创建Socket</strong>：在通信开始前，应用程序必须创建一个Socket。</li>
<li><strong>绑定Socket</strong>：服务器端需要将Socket绑定到一个特定的IP地址和端口号。</li>
<li><strong>监听连接（服务器端）</strong>：服务器端Socket进入监听状态，等待客户端连接。</li>
<li><strong>连接Socket（客户端）</strong>：客户端Socket尝试连接到服务器端Socket的IP地址和端口号。</li>
<li><strong>发送和接收数据</strong>：连接建立后，双方可以通过Socket发送和接收数据。</li>
<li><strong>关闭Socket</strong>：通信结束后，双方需要关闭Socket，释放资源。</li>
</ol>
<h3 id="Socket类型"><a href="#Socket类型" class="headerlink" title="Socket类型"></a>Socket类型</h3><p>根据使用的传输协议，Socket主要分为两种：</p>
<ol>
<li><p><strong>TCP Socket</strong>：</p>
<ul>
<li><strong>特性</strong>：面向连接，可靠的传输，保证数据按顺序到达，数据无丢失。</li>
<li><strong>使用场景</strong>：适用于需要高可靠性的数据传输，如HTTP、FTP等。</li>
<li><strong>函数</strong>：常用的函数有<code>socket()</code>, <code>bind()</code>, <code>listen()</code>, <code>accept()</code>, <code>connect()</code>, <code>send()</code>, <code>recv()</code>, <code>close()</code>。</li>
</ul>
</li>
<li><p><strong>UDP Socket</strong>：</p>
<ul>
<li><strong>特性</strong>：无连接，不保证数据的顺序和可靠性，传输速度快。</li>
<li><strong>使用场景</strong>：适用于实时性要求高但对数据可靠性要求不高的场景，如视频流、在线游戏、DNS查询等。</li>
<li><strong>函数</strong>：常用的函数有<code>socket()</code>, <code>bind()</code>, <code>sendto()</code>, <code>recvfrom()</code>, <code>close()</code>。</li>
</ul>
</li>
</ol>
<h3 id="Socket编程示例"><a href="#Socket编程示例" class="headerlink" title="Socket编程示例"></a>Socket编程示例</h3><p>下面是一个简单的TCP Socket编程示例，分别展示服务器端和客户端的实现（使用Python编写）：</p>
<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP/IP套接字</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定套接字到服务器地址和端口</span></span><br><span class="line">server_address = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">65432</span>)</span><br><span class="line">server_socket.bind(server_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听连接</span></span><br><span class="line">server_socket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;等待连接...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受连接</span></span><br><span class="line">    connection, client_address = server_socket.accept()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;连接来自&quot;</span>, client_address)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 接收数据并响应</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;收到数据:&quot;</span>, data.decode())</span><br><span class="line">                connection.sendall(data)  <span class="comment"># 回传数据</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        connection.close()</span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个TCP/IP套接字</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到服务器</span></span><br><span class="line">server_address = (<span class="string">&#x27;localhost&#x27;</span>, <span class="number">65432</span>)</span><br><span class="line">client_socket.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    message = <span class="string">&#x27;Hello, Server!&#x27;</span></span><br><span class="line">    client_socket.sendall(message.encode())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 接收响应</span></span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收到响应:&quot;</span>, data.decode())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    client_socket.close()</span><br></pre></td></tr></table></figure>

<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol>
<li><p>**socket()**：</p>
<ul>
<li>用于创建一个新的套接字。</li>
<li>参数包括地址族（如AF_INET表示IPv4）和套接字类型（如SOCK_STREAM表示TCP，SOCK_DGRAM表示UDP）。</li>
</ul>
</li>
<li><p>**bind()**：</p>
<ul>
<li>将套接字绑定到指定的IP地址和端口。</li>
<li>只有服务器端需要绑定。</li>
</ul>
</li>
<li><p>**listen()**：</p>
<ul>
<li>在指定的端口监听连接请求。</li>
<li>参数指定了允许的最大连接数。</li>
</ul>
</li>
<li><p>**accept()**：</p>
<ul>
<li>接受一个连接请求，返回一个新的套接字对象和客户端地址。</li>
<li>服务器端使用。</li>
</ul>
</li>
<li><p>**connect()**：</p>
<ul>
<li>连接到远程服务器。</li>
<li>客户端使用。</li>
</ul>
</li>
<li><p>**send()和recv()**：</p>
<ul>
<li>用于发送和接收数据。</li>
<li>在TCP套接字中，<code>send()</code>和<code>recv()</code>用于传输数据。</li>
<li>在UDP套接字中，使用<code>sendto()</code>和<code>recvfrom()</code>。</li>
</ul>
</li>
<li><p>**close()**：</p>
<ul>
<li>关闭套接字，释放资源。</li>
</ul>
</li>
</ol>
<h3 id="例子解释"><a href="#例子解释" class="headerlink" title="例子解释"></a>例子解释</h3><p>在上面的例子中：</p>
<ul>
<li>服务器端创建了一个TCP套接字，并将其绑定到本地地址<code>localhost</code>和端口<code>65432</code>，然后开始监听连接请求。</li>
<li>当客户端连接时，服务器接受连接，创建一个新的套接字用于与客户端通信。</li>
<li>服务器接收来自客户端的数据，并回传相同的数据。</li>
<li>客户端创建一个TCP套接字，连接到服务器，发送数据并接收响应。</li>
</ul>
<p>通过Socket编程，应用程序可以在不同计算机或网络设备之间实现高效的数据传输和通信。如果你还有其他问题或需要更详细的解释，请随时告诉我！</p>
<h1 id="socket和API的关系与区别"><a href="#socket和API的关系与区别" class="headerlink" title="socket和API的关系与区别"></a>socket和API的关系与区别</h1><p>![[Pasted image 20240620171800.png]]</p>
<h3 id="Socket和API的关系与区别"><a href="#Socket和API的关系与区别" class="headerlink" title="Socket和API的关系与区别"></a>Socket和API的关系与区别</h3><p>Socket和API是计算机网络和软件开发中两个重要的概念，但它们的作用和使用场景有所不同。</p>
<h4 id="1-Socket"><a href="#1-Socket" class="headerlink" title="1. Socket"></a>1. Socket</h4><p><strong>Socket（套接字）</strong>是一种底层网络通信机制，允许不同设备之间进行数据传输。Socket提供了一个接口，使应用程序能够通过网络发送和接收数据。Socket可以使用不同的传输协议，如TCP和UDP。</p>
<ul>
<li><strong>主要用途</strong>：用于建立网络连接，实现设备间的数据传输。</li>
<li><strong>工作方式</strong>：通过创建、绑定、监听、连接、发送、接收、关闭等操作，进行数据通信。</li>
<li><strong>使用场景</strong>：需要进行低级别的网络通信时，如实现自定义协议、实时通信等。</li>
</ul>
<h4 id="2-API"><a href="#2-API" class="headerlink" title="2. API"></a>2. API</h4><p><strong>API（Application Programming Interface，应用程序编程接口）</strong>是一组定义和协议，允许不同软件组件或系统之间进行交互。API可以是操作系统、库、框架提供的函数或方法，也可以是Web服务提供的接口（如REST API）。</p>
<ul>
<li><strong>主要用途</strong>：提供标准化的接口，使开发者可以使用现有的软件功能和服务，而不需要了解其内部实现细节。</li>
<li><strong>工作方式</strong>：通过函数调用或HTTP请求，与底层系统、库或远程服务进行交互。</li>
<li><strong>使用场景</strong>：需要复用现有功能或服务时，如访问数据库、调用操作系统功能、与远程Web服务交互等。</li>
</ul>
<h3 id="Socket与API的关系"><a href="#Socket与API的关系" class="headerlink" title="Socket与API的关系"></a>Socket与API的关系</h3><p>Socket可以被看作是API的一种特定实现形式。许多编程语言和操作系统提供了Socket API，用于进行底层的网络通信。例如，Python的<code>socket</code>模块、Java的<code>java.net.Socket</code>类等。</p>
<p>此外，API也可以使用Socket来实现网络通信。例如，许多Web API在后台使用HTTP协议，而HTTP协议本身是通过TCP Socket传输数据的。</p>
<h3 id="Socket与API的区别"><a href="#Socket与API的区别" class="headerlink" title="Socket与API的区别"></a>Socket与API的区别</h3><ol>
<li><p><strong>抽象层次</strong>：</p>
<ul>
<li><strong>Socket</strong>：位于网络通信的底层，直接处理数据包的传输和连接管理。</li>
<li><strong>API</strong>：位于软件开发的高层，提供标准化的接口，隐藏了底层实现细节。</li>
</ul>
</li>
<li><p><strong>使用目的</strong>：</p>
<ul>
<li><strong>Socket</strong>：用于实现低级别的网络通信和自定义协议。</li>
<li><strong>API</strong>：用于复用现有功能和服务，提高开发效率。</li>
</ul>
</li>
<li><p><strong>开发复杂度</strong>：</p>
<ul>
<li><strong>Socket</strong>：需要处理很多细节，如连接管理、错误处理、数据格式等，开发复杂度较高。</li>
<li><strong>API</strong>：通常只需调用提供的接口，不需要关心底层实现，开发复杂度较低。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>Socket</strong>：实时通信（如在线游戏、即时通讯）、实现自定义协议、低延迟要求的应用。</li>
<li><strong>API</strong>：访问Web服务（如天气查询、支付网关）、调用操作系统功能、使用第三方库功能等。</li>
</ul>
</li>
</ol>
<h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><h4 id="Socket示例"><a href="#Socket示例" class="headerlink" title="Socket示例"></a>Socket示例</h4><p>一个简单的Socket通信示例：</p>
<p><strong>服务器端（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_socket.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">65432</span>))</span><br><span class="line">server_socket.listen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;服务器正在等待连接...&quot;</span>)</span><br><span class="line">conn, addr = server_socket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;连接来自 <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;收到数据:&quot;</span>, data.decode())</span><br><span class="line">conn.sendall(data)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">server_socket.close()</span><br></pre></td></tr></table></figure>

<p><strong>客户端（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">65432</span>))</span><br><span class="line"></span><br><span class="line">message = <span class="string">&#x27;Hello, Server!&#x27;</span></span><br><span class="line">client_socket.sendall(message.encode())</span><br><span class="line"></span><br><span class="line">data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;收到响应:&quot;</span>, data.decode())</span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure>

<h4 id="API示例"><a href="#API示例" class="headerlink" title="API示例"></a>API示例</h4><p>一个简单的API调用示例（使用Python的<code>requests</code>库调用REST API）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    data = response.json()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;收到数据:&quot;</span>, data)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求失败，状态码:&quot;</span>, response.status_code)</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Socket</strong>：提供低级别的网络通信接口，用于设备间的数据传输。</li>
<li><strong>API</strong>：提供高层次的编程接口，用于复用现有功能和服务。</li>
</ul>
<p>它们在软件开发中各有用途，开发者可以根据具体需求选择适合的技术。希望这些解释对你有帮助！如果你还有其他问题，请随时告诉我。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://qhiqiefnqe-f.github.io">Hrein</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://qhiqiefnqe-f.github.io/2024/06/20/Diary/2024_6_20/">https://qhiqiefnqe-f.github.io/2024/06/20/Diary/2024_6_20/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qhiqiefnqe-f.github.io" target="_blank">Hrein's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/backend/">backend</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/Screenshot_2024-08-13-16-39-50-25_2332cb9b27b851b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/06/29/Diary/2024_6_29/" title="📕D2024_6_29"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">📕D2024_6_29</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/Screenshot_2024-08-13-16-39-50-25_2332cb9b27b851b.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hrein</div><div class="author-info__description">wuhu</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E5%92%8CRocketMQ"><span class="toc-number">1.</span> <span class="toc-text">Kafka和RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-number">1.1.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ"><span class="toc-number">1.2.</span> <span class="toc-text">RocketMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">两者的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%8F%A3%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是端口？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.1.</span> <span class="toc-text">端口的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.0.2.</span> <span class="toc-text">端口号的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text">端口的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.0.4.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAPI"><span class="toc-number">3.</span> <span class="toc-text">什么是API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAPI-1"><span class="toc-number">3.0.1.</span> <span class="toc-text">什么是API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.2.</span> <span class="toc-text">API的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">3.0.3.</span> <span class="toc-text">API的组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.4.</span> <span class="toc-text">API的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.0.5.</span> <span class="toc-text">API的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.0.6.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFsocket"><span class="toc-number">4.</span> <span class="toc-text">什么是socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSocket"><span class="toc-number">4.0.1.</span> <span class="toc-text">什么是Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.0.2.</span> <span class="toc-text">Socket的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.3.</span> <span class="toc-text">Socket类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.0.4.</span> <span class="toc-text">Socket编程示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-number">4.0.5.</span> <span class="toc-text">详细解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E8%A7%A3%E9%87%8A"><span class="toc-number">4.0.6.</span> <span class="toc-text">例子解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket%E5%92%8CAPI%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">socket和API的关系与区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E5%92%8CAPI%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.1.</span> <span class="toc-text">Socket和API的关系与区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Socket"><span class="toc-number">5.0.1.1.</span> <span class="toc-text">1. Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-API"><span class="toc-number">5.0.1.2.</span> <span class="toc-text">2. API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E4%B8%8EAPI%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.0.2.</span> <span class="toc-text">Socket与API的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket%E4%B8%8EAPI%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.3.</span> <span class="toc-text">Socket与API的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">5.0.4.</span> <span class="toc-text">示例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">Socket示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">API示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.0.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/other/hexo/" title="🌏HEXO">🌏HEXO</a><time datetime="2024-09-15T14:53:29.000Z" title="发表于 2024-09-15 22:53:29">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/leetCodeNote/1.%E6%95%B0%E7%BB%84/" title="🚷数组">🚷数组</a><time datetime="2024-09-07T06:28:29.000Z" title="发表于 2024-09-07 14:28:29">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/Diary/2024_9_7/" title="📕D2024_9_7">📕D2024_9_7</a><time datetime="2024-09-07T06:28:29.000Z" title="发表于 2024-09-07 14:28:29">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/leetCodeNote/4.%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="🚷字符串">🚷字符串</a><time datetime="2024-09-07T06:28:29.000Z" title="发表于 2024-09-07 14:28:29">2024-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/leetCodeNote/2.%E9%93%BE%E8%A1%A8/" title="🚷链表">🚷链表</a><time datetime="2024-09-07T06:28:29.000Z" title="发表于 2024-09-07 14:28:29">2024-09-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/qhiqiefnqe-f/picgo/img/IMG_20240915_160126(1).jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Hrein</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>